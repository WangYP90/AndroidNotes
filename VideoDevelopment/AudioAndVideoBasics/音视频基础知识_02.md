## 音视频基础
### 音频基础
声音是由物体振动而产生的
声波的三要素 频率、振幅和波形。

* 频率代表音阶的高低
频率（过零率）越高，波长就越短，低频声响的波长则较长。所以其可以更容易地绕过障碍物，
* 振幅代表响度
* 波形代表音色

### MediaPlayer
#### 创建过程
```java
这里只介绍create方法来创建MediaPlayer
 public static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder,
            AudioAttributes audioAttributes, int audioSessionId) {

        try {
            MediaPlayer mp = new MediaPlayer();
            //声音相关处理,若为空,就创建一个.
            final AudioAttributes aa = audioAttributes != null ? audioAttributes :
                new AudioAttributes.Builder().build();
            //设置音频属性
            mp.setAudioAttributes(aa);
            //设置声音的会话ID,视频和音频是分开渲染的.
            mp.setAudioSessionId(audioSessionId);
            //把url地址传入到底层
            mp.setDataSource(context, uri);
            //判断SurfaceHolder是否为空,这是一个控制器,Surface的控制器,用来操作Surface,处理它在Canvas上作画的效果和动画,控制表面、大小、像素等。
            if (holder != null) {
                mp.setDisplay(holder);
            }
            mp.prepare();//开始准备
            return mp;//返回
        } catch (IOException ex) {
            Log.d(TAG, "create failed:", ex);
            // fall through
        } catch (IllegalArgumentException ex) {
            Log.d(TAG, "create failed:", ex);
            // fall through
        } catch (SecurityException ex) {
            Log.d(TAG, "create failed:", ex);
            // fall through
        }

        return null;
    }
```
#### MediaPlayer.cpp
```c++
   static void android_media_MediaPlayer_native_init(JNIEnv *env) //可以理解为一个万能的指针表,通过操作符(->)访问JNI中的函数
   {
       jclass clazz;//类的句柄
       clazz = env->FindClass("android/media/MediaPlayer");
       //这里通过Native层调用Java层,获取MediaPlayer对象
       if(clazz == NULL){
       	return;
       }
       //获取成员变量mNativeConext,它在MediaPlayer.java中是一个long型整数实际对应的是一个内存地址.
       if(fields.context = NULL){
       	return;
       }
       fields.post_event = env->GetstaticMethodID(clazz,"postEventFromNative","(Ljava/lang/Object;IIILjava/lang/Object;)V");
       if(fields.post_event == NULL){
           return;
       }
}
       //省略部分代码
       /*
       上面的这种方式是通过JNI调用Java层的MediaPlayer类,然后拿到mNativeContext 的指针,接着调用MediaPlayer.java中的静态方法postEventFromNative,把Native的事件回调到Java层,使用EventHandler post事件回到主线程中,用软引用指向原生的MediaPlayer,以保证Native代码是安全的.
       */
priveate static void postEventFromNative(Object mediaplayer_ref,int what, int arg1, int arg2,Object obj){
    MediaPlayer mp = (Mediaplayer)((WeakReference)mediaplayer_ref).get();//得到软引用对象
    if(mp == null){
    	return;
    }
    //省略部分代码
    if(mp.mEventHandler != null){
        Message m = mp.mEventHandler.obtainMessage(what,arg1,arg2,obj);
        mp.mEventHandler.sendMessage(m);
    }
}
/*之前我们再Java层的MediaPlayer.java文件的构造函数中,分析到最后有一个native_setuo,在android_media_MediaPlayer.cpp中找到对应的函数,
*/
static void android_media_MediaPlayer_native_setup(JNIEnv *env,jobject thiz,jobject weak_this){
    sp<MediaPlayer> mp = MediaPlayer();
    //省略部分代码
    //给MediaPlayer 创建一个listener,以便我们再java层设置的setPrepareListener、setOnCompleteListener能产生回调
    sp<JNIMediaPlayerListener> listener = new JNIMediaPlayerListener(env,thiz,weak_this);
    mp->setListener(listener);
    //对于Java层来说,C++中的MediaPlayer是不透明的,也无须关心其对应的逻辑,各司其职.
    setMediaPlayer(env,thiz,mp);
}
//可以看到会设置一些会调用的listener及创建C++中的MediaPlayer对象.
```
#### setDataSource 过程
上面是对MediaPlayer的构造过程,接下来就是setDataSource过程:
```java
public void setDataSource(String path){
	  setDataSource(path, null, null);
}
//setDatasource 包含文件或HTTP/RTSP地址
private void setDataSource(String path, Map<String, String> headers, List<HttpCookie> cookies)
            throws IOException, IllegalArgumentException, SecurityException, IllegalStateException
    {
        String[] keys = null;
        String[] values = null;

        if (headers != null) {
            keys = new String[headers.size()];//请求头的key
            values = new String[headers.size()];//请求头的value

            int i = 0;
            //把HTTP/RTSP 消息头分别封到两个数组中
            for (Map.Entry<String, String> entry: headers.entrySet()) {
                keys[i] = entry.getKey();
                values[i] = entry.getValue();
                ++i;
            }
        }
        setDataSource(path, keys, values, cookies);
    }
    
    
private void setDataSource(String path, String[] keys, String[] values,List<HttpCookie> cookies)
            throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
        final Uri uri = Uri.parse(path);//解析path
        final String scheme = uri.getScheme();
        if ("file".equals(scheme)) {
            path = uri.getPath();
        } else if (scheme != null) {
        	//1.处理非文件资源
            // handle non-file sources
            nativeSetDataSource(
                MediaHTTPService.createHttpServiceBinderIfNecessary(path, cookies),
                path,
                keys,
                values);
            return;
        }
		//2.处理文件类型
        final File file = new File(path);
        if (file.exists()) {
            FileInputStream is = new FileInputStream(file);
            FileDescriptor fd = is.getFD();//得到文件标识符
            setDataSource(fd);
            is.close();
        } else {
            throw new IOException("setDataSource failed.");
        }
    }
//调到这里
public void setDataSource(FileDescriptor fd)
            throws IOException, IllegalArgumentException, IllegalStateException {
        // intentionally less than LONG_MAX
        setDataSource(fd, 0, 0x7ffffffffffffffL);
    }
public void setDataSource(FileDescriptor fd, long offset, long length)
            throws IOException, IllegalArgumentException, IllegalStateException {
        _setDataSource(fd, offset, length);
    }

private native void _setDataSource(FileDescriptor fd, long offset, long length)
            throws IOException, IllegalArgumentException, IllegalStateException;
/*开始进入JNI层,发现找不到android_media_MediaPlayer_setDataSource函数,但发现有一个函数名映射函数声明,这是JNI中的常用动态注册方法.
*/
static JNINativeMethod gMethods[] = {
    {
        "nativeSetDataSource",
        "(Landroid/os/IBinder;Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)V",
        (void *)android_media_MediaPlayer_setDataSourceAndHeaders
    },
    {"_setDataSource",	"(Ljava/io/FileDescriptor;JJ)V",
     (void *)android_media_MediaPlayer_setDataSourceFD
    },
    {"_setDataSource",	"(Landroid/media/MediaDataSource;)V",
	 (void *)android_media_MediaPlayer_setDataSourceCallback
    }
    {"_setDataSourface", "(Landroid/view/Surface;)V",
	 (void *)android_media_MediaPlayer_setVideoSurface
    },
}
//省略相关函数名映射native 函数声明
/*以上这些都是函数名映射,看过JNIEnv * 源码的话,应该不会陌生,无非还是映射,不影响我们分析.
    下面对android_media_MediaPlayer_setDataSourceFD函数进行分析:
*/
 static void android_media_MediaPlayer_setDataSourceFD(JNIEnv *env,jobject thiz,jobject fileDescriptor,jlong offset,jlong length)
 {	//得到MediaPlayer对象
     sp<MediaPlayer> mp = getMediaPlayer(env,thiz);
     //省略抛出异常代码
     //在JNI中获取java.io.FileDescriptor
     int fd = jniGetFDFromFileDescriptor(env,fileDescriptor);
     ALOGV("setDataSourceFD：fd %d",fd);//这是一句输出log 打印
     process_media_player_call( env, thiz, mp->setDataSource( fd, offset, length), "java/io/IOException", "setDataSourceFD failed.");
 }
//这里开始调用 JNIEnv* 中的 GetIntField 函数获取对应的变量
int jniGetFDFromFileDescriptor(JNIEnv *env,jobject fileDescriptor){
    return (*env)->GetIntField( env, FileDescriptor, gCachedFields.DescriptorField);
}
//接着分析 process_media_player_call 函数:
static void process_media_player_call(JNIEnv *env, jobject thiz,status_t opStatus, const char* exception, const char *message)
{
    if(exception == NULL){ //不抛出异常,发送一个onError事件
        if(excption == NULL){ //如果setDataSource过程中opStatus不ok
           sp<MediaPlayer> mp = getMediaPlayer(env, thiz);
            if(mp != 0){
                mp->notify(MEDIA_ERROR, opStatus, 0);
                //通知MEDIA_ERROR
            }
        }
    }
    //省略抛出异常部分代码
}
/*
总结以上代码: 当 mp->setDataSource(fd, offset, length)函数得到状态后,对各种状态进行通知.有异常的直接抛出,这样也就不会影响MediaPlayer后面的执行过程了.
下面是HTTP/RTSP传入JNI.在java层中对应的nativeSetDataSource函数:
*/
private native void nativeSetDataSource(IBinder httpServiceBinder, String path, String[] keys, String[] values)throws IOException, IllegalArgumentException, SecurityException,IllegalStateException;
//在JNI中通过映射表可对应到adroid_media_MediaPlayer_setDataSourceAndHeaders函数:
static void adroid_media_MediaPlayer_setDataSourceAndHeaders(JNIEnv *env,jobject thiz, jobject httpServiceBinderObj, jstring path, jobjectArray keys, jobjectArray values)
{
    //获取MediaPlayer对象
    sp<MediaPlayer> mp = getMediaPlayer(env, thiz);
    //省略判空,抛出异常的代码
    const char *tmp = env->GetStringUTFChars(path, NULL);
    if(tmp == NULL){ //内存溢出
        return;
    }
    ALOGV("setDataSource: path %s", tmp);
    String8 pathStr(tmp);
    env->ReleaseStringUTFChars(path, tmp);
    tmp = NULL;
    //省略部分代码
    sp<IMediaHTTPService> httpService;
    if(httpServiceBinderObj != NULL){
        sp<IBinder> binder = ibinderForJavaObject(env, httpServiceBinderObj);
        //通过Binder机制将httpServiceBinderObj 传给IPC并返回给binder
        //然后强制转换为IMediaHTTPService
        httpService = interface_cast<IMediaHTTPService>(binder);
    }
}







```

