## 音视频基础
### 音频基础
声音是由物体振动而产生的
声波的三要素 频率、振幅和波形。

* 频率代表音阶的高低
频率（过零率）越高，波长就越短，低频声响的波长则较长。所以其可以更容易地绕过障碍物，
* 振幅代表响度
* 波形代表音色

### MediaPlayer
#### 创建过程
```java
这里只介绍create方法来创建MediaPlayer
 public static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder,
            AudioAttributes audioAttributes, int audioSessionId) {

        try {
            MediaPlayer mp = new MediaPlayer();
            //声音相关处理,若为空,就创建一个.
            final AudioAttributes aa = audioAttributes != null ? audioAttributes :
                new AudioAttributes.Builder().build();
            //设置音频属性
            mp.setAudioAttributes(aa);
            //设置声音的会话ID,视频和音频是分开渲染的.
            mp.setAudioSessionId(audioSessionId);
            //把url地址传入到底层
            mp.setDataSource(context, uri);
            //判断SurfaceHolder是否为空,这是一个控制器,Surface的控制器,用来操作Surface,处理它在Canvas上作画的效果和动画,控制表面、大小、像素等。
            if (holder != null) {
                mp.setDisplay(holder);
            }
            mp.prepare();//开始准备
            return mp;//返回
        } catch (IOException ex) {
            Log.d(TAG, "create failed:", ex);
            // fall through
        } catch (IllegalArgumentException ex) {
            Log.d(TAG, "create failed:", ex);
            // fall through
        } catch (SecurityException ex) {
            Log.d(TAG, "create failed:", ex);
            // fall through
        }

        return null;
    }
```
#### MediaPlayer.cpp
```c++
   static void android_media_MediaPlayer_native_init(JNIEnv *env) //可以理解为一个万能的指针表,通过操作符(->)访问JNI中的函数
   {
       jclass clazz;//类的句柄
       clazz = env->FindClass("android/media/MediaPlayer");
       //这里通过Native层调用Java层,获取MediaPlayer对象
       if(clazz == NULL){
       	return;
       }
       //获取成员变量mNativeConext,它在MediaPlayer.java中是一个long型整数实际对应的是一个内存地址.
       if(fields.context = NULL){
       	return;
       }
       fields.post_event = env->GetstaticMethodID(clazz,"postEventFromNative","(Ljava/lang/Object;IIILjava/lang/Object;)V");
       if(fields.post_event == NULL){
           return;
       }
}
       //省略部分代码
       /*
       上面的这种方式是通过JNI调用Java层的MediaPlayer类,然后拿到mNativeContext 的指针,接着调用MediaPlayer.java中的静态方法postEventFromNative,把Native的事件回调到Java层,使用EventHandler post事件回到主线程中,用软引用指向原生的MediaPlayer,以保证Native代码是安全的.
       */
priveate static void postEventFromNative(Object mediaplayer_ref,int what, int arg1, int arg2,Object obj){
    MediaPlayer mp = (Mediaplayer)((WeakReference)mediaplayer_ref).get();//得到软引用对象
    if(mp == null){
    	return;
    }
    //省略部分代码
    if(mp.mEventHandler != null){
        Message m = mp.mEventHandler.obtainMessage(what,arg1,arg2,obj);
        mp.mEventHandler.sendMessage(m);
    }
}
/*之前我们再Java层的MediaPlayer.java文件的构造函数中,分析到最后有一个native_setuo,在android_media_MediaPlayer.cpp中找到对应的函数,
*/
static void android_media_MediaPlayer_native_setup(JNIEnv *env,jobject thiz,jobject weak_this){
    sp<MediaPlayer> mp = MediaPlayer();
    //省略部分代码
    //给MediaPlayer 创建一个listener,以便我们再java层设置的setPrepareListener、setOnCompleteListener能产生回调
    sp<JNIMediaPlayerListener> listener = new JNIMediaPlayerListener(env,thiz,weak_this);
    mp->setListener(listener);
    //对于Java层来说,C++中的MediaPlayer是不透明的,也无须关心其对应的逻辑,各司其职.
    setMediaPlayer(env,thiz,mp);
}
//可以看到会设置一些会调用的listener及创建C++中的MediaPlayer对象.
```
#### setDataSource 过程
上面是对MediaPlayer的构造过程,接下来就是setDataSource过程:
```java
public void setDataSource(String path){
	  setDataSource(path, null, null);
}
//setDatasource 包含文件或HTTP/RTSP地址
private void setDataSource(String path, Map<String, String> headers, List<HttpCookie> cookies)
            throws IOException, IllegalArgumentException, SecurityException, IllegalStateException
    {
        String[] keys = null;
        String[] values = null;

        if (headers != null) {
            keys = new String[headers.size()];//请求头的key
            values = new String[headers.size()];//请求头的value

            int i = 0;
            //把HTTP/RTSP 消息头分别封到两个数组中
            for (Map.Entry<String, String> entry: headers.entrySet()) {
                keys[i] = entry.getKey();
                values[i] = entry.getValue();
                ++i;
            }
        }
        setDataSource(path, keys, values, cookies);
    }
    
    
private void setDataSource(String path, String[] keys, String[] values,List<HttpCookie> cookies)
            throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
        final Uri uri = Uri.parse(path);//解析path
        final String scheme = uri.getScheme();
        if ("file".equals(scheme)) {
            path = uri.getPath();
        } else if (scheme != null) {
        	//1.处理非文件资源
            // handle non-file sources
            nativeSetDataSource(
                MediaHTTPService.createHttpServiceBinderIfNecessary(path, cookies),
                path,
                keys,
                values);
            return;
        }
		//2.处理文件类型
        final File file = new File(path);
        if (file.exists()) {
            FileInputStream is = new FileInputStream(file);
            FileDescriptor fd = is.getFD();//得到文件标识符
            setDataSource(fd);
            is.close();
        } else {
            throw new IOException("setDataSource failed.");
        }
    }
//调到这里
public void setDataSource(FileDescriptor fd)
            throws IOException, IllegalArgumentException, IllegalStateException {
        // intentionally less than LONG_MAX
        setDataSource(fd, 0, 0x7ffffffffffffffL);
    }
public void setDataSource(FileDescriptor fd, long offset, long length)
            throws IOException, IllegalArgumentException, IllegalStateException {
        _setDataSource(fd, offset, length);
    }

private native void _setDataSource(FileDescriptor fd, long offset, long length)
            throws IOException, IllegalArgumentException, IllegalStateException;
/*开始进入JNI层,发现找不到android_media_MediaPlayer_setDataSource函数,但发现有一个函数名映射函数声明,这是JNI中的常用动态注册方法.
*/
static JNINativeMethod gMethods[] = {
    {
        "nativeSetDataSource",
        "(Landroid/os/IBinder;Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)V",
        (void *)android_media_MediaPlayer_setDataSourceAndHeaders
    },
    {"_setDataSource",	"(Ljava/io/FileDescriptor;JJ)V",
     (void *)android_media_MediaPlayer_setDataSourceFD
    },
    {"_setDataSource",	"(Landroid/media/MediaDataSource;)V",
	 (void *)android_media_MediaPlayer_setDataSourceCallback
    }
    {"_setDataSourface", "(Landroid/view/Surface;)V",
	 (void *)android_media_MediaPlayer_setVideoSurface
    },
}
//省略相关函数名映射native 函数声明
/*以上这些都是函数名映射,看过JNIEnv * 源码的话,应该不会陌生,无非还是映射,不影响我们分析.
    下面对android_media_MediaPlayer_setDataSourceFD函数进行分析:
*/
 static void android_media_MediaPlayer_setDataSourceFD(JNIEnv *env,jobject thiz,jobject fileDescriptor,jlong offset,jlong length)
 {	//得到MediaPlayer对象
     sp<MediaPlayer> mp = getMediaPlayer(env,thiz);
     //省略抛出异常代码
     //在JNI中获取java.io.FileDescriptor
     int fd = jniGetFDFromFileDescriptor(env,fileDescriptor);
     ALOGV("setDataSourceFD：fd %d",fd);//这是一句输出log 打印
     process_media_player_call( env, thiz, mp->setDataSource( fd, offset, length), "java/io/IOException", "setDataSourceFD failed.");
 }
//这里开始调用 JNIEnv* 中的 GetIntField 函数获取对应的变量
int jniGetFDFromFileDescriptor(JNIEnv *env,jobject fileDescriptor){
    return (*env)->GetIntField( env, FileDescriptor, gCachedFields.DescriptorField);
}
//接着分析 process_media_player_call 函数:
static void process_media_player_call(JNIEnv *env, jobject thiz,status_t opStatus, const char* exception, const char *message)
{
    if(exception == NULL){ //不抛出异常,发送一个onError事件
        if(excption == NULL){ //如果setDataSource过程中opStatus不ok
           sp<MediaPlayer> mp = getMediaPlayer(env, thiz);
            if(mp != 0){
                mp->notify(MEDIA_ERROR, opStatus, 0);
                //通知MEDIA_ERROR
            }
        }
    }
    //省略抛出异常部分代码
}
/*
总结以上代码: 当 mp->setDataSource(fd, offset, length)函数得到状态后,对各种状态进行通知.有异常的直接抛出,这样也就不会影响MediaPlayer后面的执行过程了.
下面是HTTP/RTSP传入JNI.在java层中对应的nativeSetDataSource函数:
*/
private native void nativeSetDataSource(IBinder httpServiceBinder, String path, String[] keys, String[] values)throws IOException, IllegalArgumentException, SecurityException,IllegalStateException;
//在JNI中通过映射表可对应到adroid_media_MediaPlayer_setDataSourceAndHeaders函数:
static void adroid_media_MediaPlayer_setDataSourceAndHeaders(JNIEnv *env,jobject thiz, jobject httpServiceBinderObj, jstring path, jobjectArray keys, jobjectArray values)
{
    //获取MediaPlayer对象
    sp<MediaPlayer> mp = getMediaPlayer(env, thiz);
    //省略判空,抛出异常的代码
    const char *tmp = env->GetStringUTFChars(path, NULL);
    if(tmp == NULL){ //内存溢出
        return;
    }
    ALOGV("setDataSource: path %s", tmp);
    String8 pathStr(tmp);
    env->ReleaseStringUTFChars(path, tmp);
    tmp = NULL;
    //省略部分代码
    sp<IMediaHTTPService> httpService;
    if(httpServiceBinderObj != NULL){
        sp<IBinder> binder = ibinderForJavaObject(env, httpServiceBinderObj);
        //通过Binder机制将httpServiceBinderObj 传给IPC并返回给binder
        //然后强制转换为IMediaHTTPService
        httpService = interface_cast<IMediaHTTPService>(binder);
    }
    //开始判断状态,和上面的文件操作是一样的
    status_t opStatus = mp->setDataSource(httpService, pathStr, headerVector.size() > 0?headersVector : NULL);
    //见上面的文件操作
    process_media_player_call(env, thiz, opStatus, "java/io/IOException", "setDataSource failed.");
}
/*至此,setDataSource过程就完成了,这里需要注意两点,一点是从Java->JNI->C++ 的正向调用过程(前面从java层到Native层都是正向过程),一点是C++ -> JNI->java的过程(如mp->setDataSource(httpService, pathStr, headersVector.size()>0 ? headersVector: NULL)),这样回调的好处是什么? 有几点:
	安全性,封装在Native层的代码是so形式的,破坏性风险小.
	效率高,在运行速度上C++执行时间短,且底层也是C++语言编写的.对于复杂的渲染及时间要求高的渲染,放在Native层是最好不过的选择.
	连通性,正向调用将值传入,反向调用把处理过的值通知回去.相当于一根管道.
*/


```
#### setDisplay过程
```java
public void setDisplay(SurfaceHolder sh)
{
	nSurfaceHolder = sh;// 1. 给Surface设置一个控制器,用于展示视频图像
	Surface surface;
	if (sh != null) {
		surface = sh.getSurface();
	} else {
		surface = null;
	}
	_setVideoSurface(surface);//2.给视频设置Surface,带_的函数是native函数
	updateSurfaceScreenOn();//3.更新Surface到屏幕上
}
//对于上面代码中的第2点,同样在android_media_MediaPlayer.cpp中找到其对应的函数
static void android_media_MediaPlayer_setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface)
{
	setVideoSurface(env, thiz, jsurface, true);
}
static void setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBealive)
{
	sp<MediaPlayer> mp = getMediaPlayer(env, thiz);
	//省略抛出异常的代码
	decVideoSurfaceRef(env, thiz);
	//IGraphicBufferProducer
	sp<IGraphicBufferProducer> new_st;
	if(jsurface){
		//得到Java层的Surface
		sp<Surface> surface(android_view_Surface_getSurface(env,jsurface));
		if(surface != NULL){
			new_st = surface->getIGraphicBufferProducer();
			//省略抛出异常的代码
			//调用incStrong
			new_st->incStrong((void*)decVideoSurfaceRef);
		} else {
            //省略抛出异常的代码
            return;
		}
	}
	env->SetLongField(thiz, fields.surface_texture, (jlong)new_st.get());
	/*如果MediaPlayer还未被初始化,setDataSource将失败,但setDataSurce之前就setDiaplay了,在prepare/prepareAsync中调用setVideoSurfaceTexture可以覆盖该case
	*/
	mp->setVideoSurfaceTexture(new_st);
}

static void decVideoSurfaceRef(JNIEnv *env, jobject thiz)
{
	sp<MediaPlayer> mp = getMediaPlayer(env, thiz);
	//省略部分代码
	//得到旧的SurfaceTexture
	sp<IGraphicBufferProducer> old_st = getVideoSurfaceTexture(env, thiz);
	if(old_st != NULL){
        old_st->decStrong((void*)decVideoSurfaceRef);
	}
}
/*这里有几个概念:
SurfaceTexture: SurfaceTexture 是Android 3.0加入的一个类,这个类跟Surface很像,可从视频解码里面获取图像流(image stream). 但是,和SurfaceView 不同的是,SurfaceTexture在接收图像流之后,不需要显示出来.SurfaceTexture不需要显示到屏幕上,因此我们可以用SurfaceTexture 接收解码出来的图像流,然后从SurfaceTexture中取得图像帧的富而不能进行处理,处理完毕后再送给另一个SurfaceView用于显示.

Surface: 处理被屏幕排序的原生Buffer, Android中的Surface就是一个用来画图形(graphic)或图像(image)的地方,对于View及其子类,都画在SUrface上的,各Surface对象通过SurfaceFlinger合成到frameBuffer.每个Surface都是双缓冲的(实际上就是两个线程,一个渲染线程,一个UI更新线程),它有一个backBuffer 和一个frontBuffer.在Surface中创建的Canvas对象,可以来管理Surface绘图操作,Canvas对应Bitmap,存储Surface中的内容.

SurfaceView: 在Camera、MediaRecorder、MediaPlayer中SurfaceView经常被用来显示图像.SurfaceView是View的子类,实现了Parcelable接口,其中内嵌了一个专门用于绘制的Surface,SUrfaceView可以控制这个Surface的格式和尺寸,以及Surface的绘制位置.可以理解Surface就是管理数据的地方,SurfaceView就是展示数据的地方.

SurfaceHolder: 顾名思义,是一个管理SurfaceHolder的容器.SUrfaceHolder是一个接口,其可被理解为一个Surface的监听器.通过回调函数addCallback(SurfaceHolder,Callback callback)监听Surface的创建,通过获取Surface中的Canvas对象,锁定之.所得到的Canvas对象在完成修改Surface中的数据后,释放同步锁,并提交改变Surface的状态及图像,展示新的图像数据.

总结: SurfaceView中调用getHolder函数,可以获得当前SUrfaceView中的Surface对应的SurfaceHolder,SurfaceHolder开始对Surface进行管理操作.这里按MVC模式可以更好的理 解 M:Surface(图像数据)、V：SurfaceView（图像展示）、C：SurfaceHolder（图像数据管理）.MediaPlayer.java中的setDisplay操作就是对将要显示的视频进行预设置.

*/

```
#### 开始 prepare 后的流程
