[TOC]
# OpenGL ES 入门
* 什么是OpenGL,`OpenGL 开放图形库或者开放式图形库,是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口。`
* OpenGL ES ，在移动平台上使用的是一个特殊的嵌入式版本，叫做OpenGL ES
## 数学准备
### 角度和弧度
`角度制是非常自然的,但是引入弧度制就懵逼了,为什么有了角度还要引入弧度,为什么角度与弧度互相转换.`
- 角度  
角度的出现,是源于对圆周运动的观察,古人经过长时间的观察发现,地球围绕太阳公转,并得出循环周期为360天的规律.所以圆被分为360等份.
- 弧度  
`弧度是角的度量单位,它是由国际单位制导出的单位,单位缩写rad`  
`定义:弧长等于半径的弧,其所对圆心角为1弧度. (即两条射线从圆心向两周射出,形成一个夹角正对的弧,当弧长正好等于圆的半径时,两条射线的夹角的弧度为1)`
```
根据定义 一周的弧度为:
1弧度 = 弧长为 r(半径);

2πr/r = 2π   (那么 2πr 是圆的周长, 360度 = 2πr /r (弧度))
360° = 2π弧度

角度 与 弧度的转换
360° = 2π rad
180° = π rad
1° = (π/180) rad ≈ 0.01745 rad
rad = (180°/π) ≈ 57.30°
a度的角 = a . (π / 180)rad


弧长 = nπr/180 (n为角的度数)

圆的面积: 圆的面积 =  πr²
扇形的面积 : 扇形面积=  πr²/360°*n°;{可以简化为 (1/2) * 弧长 * 半径}

在 编程中,sin cos tan等 都在各个语言中有封装.
只需要传入弧度,根据正弦和余弦值来计算相应的坐标位置


插曲:
弧度是从圆周运动的进行者的角度来看待圆周运动的。  
之前说过，古人认为天圆地方，人们的旅行都被视为直线运动。可事实上，地球是圆的，随着人类社会的活动，大家越来越认识到传统意义上的直线在地球表面不复存在，必须重新定义直线的含义。弧度也就是在这样的环境下开始发扬光大：
```
[三角函数](https://baijiahao.baidu.com/s?id=1599406042320874051&wfr=spider&for=pc)  
[三角函数2](https://baijiahao.baidu.com/s?id=1598360045005140340&wfr=spider&for=pc)
[三角函数3](http://math001.com/inverse_trigonometric_functions/)
[三角函数4](https://blog.csdn.net/paxhujing/article/details/80456449)
[三角函数5](https://zhuanlan.zhihu.com/p/21378340)


## 准备开始
`GLSurface View初始化OpenGL,GLSurfaceView会处理OpenGL初始化过程中比较基本的操作.`
* 字节序
```
字节序(Endianness) 是描述一个硬件架构是如何组织位(bit)和字节(byte) 的方式,他的
底层组成一个数字.现实中,最常见的就是多字节数,既可以吧他们按大头序(big endian order)排列,即吧最重要的自己放在前面;或者按小头序(little endian order)排列,即把最不重要的字节放前面.
	举个例子,有十进制数10000,如果把它转成二进制数,就是10011100010000.在大头架构上,这些位就会排列成:
	00100111 00010000
	在小头的架构上,他们就会排列成:
	00010000 00100111
	这次试用十六进制再来看一下,十进制10000就是十六进制系统中的2710;因为每两个字符对应一个8位自己,在看计算机代码时,十六进制用起来更好些;在大头的架构上,这个数字会另存为:
	27 10
	而在小头的架构上,同样的数字会另存为:
	10 27
	正常情况下,我们不需要担心字节序.当使用ByteBuffer时,只需要保证它和硬件使用了同样的字节序;否则结果就会莫名其妙的错误.
```
---
* 着色器(shader)
1. 顶点着色器(vertex shader)生成每个顶点的最终位置,针对每个顶点,它都会执行一次;一旦最终位置确定了,OpenGL就可以吧这些可见顶点的集合组装成点.直线.以及三角形.
2. 片段着色器(fragment shader) 为组成点. 直线和三角形的每个片段生成最终的颜色,针对每个片段,它都会执行一次,一个片段是一个小的,单一颜色的长方形区域,类似于计算机屏幕上的一个像素.  
`一旦最后的颜色生成了,OpenGL就会把它们写到一个称为帧缓冲区(frame buffer) 的内存块中,然后,Android会把这个帧缓冲区显示到屏幕上.`

```
res/raw/simple_fragment_shader.glsl

precision mediump float;
/*
OpenGL 设计者决定吧顶点着色器的精度默认设置为最高级--- highp
高精度数据类型更加精确,但是这是以降低性能为代价的;对于片段着色器,出于最大兼容性的考虑,选择了mediump,这也是基于速度和质量的权衡.
(精度分别有  highp, mediump, lowp)

Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。
全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。
第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。我们可以在一个着色器中添加uniform关键字至类型和变量名前来
声明一个GLSL的uniform。从此处开始我们就可以在着色器中使用新声明的uniform了。

我们在片段着色器中声明了一个uniform vec4的ourColor，并把片段着色器的输出颜色设置为uniform值的内容。
因为uniform是全局变量，我们可以在任何着色器中定义它们，而无需通过顶点着色器作为中介。顶点着色器中不需要这个uniform。

如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！

这个uniform现在还是空的，我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中uniform属性的索引/位置值。
当我们得到uniform的索引/位置值后，我们就可以更新它的值了。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色。

片段着色器剩余部分和早前定义的顶点着色器一样,这次要传递一个 unifrom ,它叫u_Color,它不像属性,每个顶点都要设置一个.一个uniform会让每个
顶点都使用同一个值,除非我们再次改变它,然后在mian(),把unifrom定义的颜色 复制给 gl_FragColor
*/

uniform vec4 u_Color;

void main()
{
    gl_FragColor = u_Color;
}






res/raw/simple_vertex_shader.glsl

attribute vec4 a_Position;

// 这些着色器 使用GLSL定义,GLSL是OpenGL 的着色语言;这个着色语言的语法结构与C 语言相似.
// 对于我们定义过的每个单一的顶点,顶点着色器都会被调用一次; 当它被调用的时候,它会在a_Position属性里面接手当前顶点的位置,这个属性被定义成vec4类型.
// 一个 vec4是包含4个分量的向量;在位置的上下文中,可以认为这4个分量是x,y,z,和w坐标,x,y,z对应一个三维位置,而w 是一个特殊的坐标.如果没有指定,默认情况下,OpenGL
//都是把向量的前三个坐标设为0,并把最后一个坐标w设为1.
/*
"attribute" 就是把这些属性放进着色器的手段,之后,可以定义main(),这是着色器的主要入口点,它所做的即使把前面定义过的位置复制到指定的输出变量gl_Position;
这个着色器一定要给gl_Position 赋值; OpenGL会把gl_Position中存储的值作为当前顶点的最终位置,并把这些顶点组装 成点,直线和三角形等.
*/
void main()
{
    gl_Position = a_Position;
    gl_PointSize = 10.0;
}
```
---
### matrix(矩阵) 和向量(vector)  
- 模型矩阵
```
模型矩阵是用来把物体放在世界空间(world-space)坐标系的.比如所画的冰球模型和木槌模型,它们的初始中心点都在(0,0,0). 没有模型矩阵,这些模型就会停留在(0,0,0),如果要移动它们,那么就不得不计算后更新每个模型的每个顶点.
如果不想这么做,我们可以使用一个模型矩阵,把那些顶点与这个矩阵相乘来变换它们.
```
- 视图矩阵
```
视图矩阵是出于同模型矩阵一样的原因被使用的,但是它平等地影响场景中的每一个物体,因为它影响所有的东西,它在功能上等同于一个相机:来回移动相机,你会从不同的视角看见那些东西.

举个例子:想象一下我们要来回旋转一个场景,并把它移动一定量的距离.能实现这些的一种方式是把同样的旋转和平移调用应用于每一个单个的物体.尽管那样可行,但如果只把这些变换存到另一个矩阵,并把这个矩阵应用于每个物体,会更容易实现.

```
- 投影矩阵
```
这个矩阵帮助创建三维的幻象,通常只有当屏幕变换方位时,它才会变化.
```

---

### 纹理 texture
`OpenGL中的纹理可以用来表示图像、照片、甚至由一个数学算法生成的分形数据。每个二维的纹理都由许多小的纹理元素(texel)组成,他们是小块的数据,类似于我们前面讨论过的片段和像素.要使用纹理,最常用的方式是直接从一个图像文件加载数据.`  
#### 纹理的坐标
- **常用说法**
* 二维纹理的左下角为(0,0), 水平方向的维度称为S,垂直方向的维度称为T. 当我们想把一个纹理应用于一个三角形或一组三角形的时候,我们要为每个顶点指定一组ST纹理坐标,以便OpenGl知道需要用那个纹理的哪个部分画到每个三角形上.
* S: {(0,0),(1,0)}
* T: {(0,0), (0,1)}

- **第二种说法**
* 对于三维模型,有两个最重要的坐标系统, 一个顶点的坐标(X,Y,Z).另外一个坐标,是UV坐标.完整的说应该是UVW(因为XYZ已经被定义,所以另选三个字母).  
* U:代表图片在显示器的水平方向的坐标, 0~1,
* V:代表图片在显示器的垂直方向作坐标,0~1
* W: 贴图时二维的,没有W坐标.
* 所以一般简称UV坐标。 坐标为（U {(0,0),(1,0)}, V{(0,0), (0,1)}）

`在OpenGl ES 2.0中,纹理不必是正方形,但是每个维度都应该是2个幂(POT 前面带个NPOT就是不是2的幂{non power of two}),每个维度都是这样的一个数字,如128,256,512等.这样的规定在与非POT纹理可以被使用的场景非常有限,而POT纹理适合各种场景.`
```
所以在 OpenGL中使用的纹理坐标应该是这样的,比如一张宽度512高度1024的图片,那么它的纹理坐标应该是0,0   1,0  1,1 0,1,
如果需要对纹理进行裁剪那么坐标可以是这样的, 
0.5,0.5(中心点)
0f,0.9f,
1f,0.9f,
1f,0.1f,
0f,0.1f,
0f,0.9f

```

#### 纹理过滤器
* 最近邻过滤器  
`这种方式为每个片段选择最近的纹理元素.当我们放大纹理时,它的锯齿效果看起来相当明显.每个纹理单元都清除的显示为一个小方块,当我们缩小纹理时,因为没有足够的片段用来绘制所有的纹理单元,许多细节将会丢失.`
* 双线性过滤器  
`双线性过滤使用双线性插值平滑像素之间的过渡,而不是为每个片段使用最近的纹理元素,OpenGL 会使用四个临近的纹理元素,并在他们之间用一个线性插值算法做插值,这个算法与我们4.3.2节中讨论过的算法一样.我们之所以叫它双线性,是因为它是沿着两个维度插值的.`  
* MIP贴图  
`尽管双线性过滤器很适合处理放大,但是对于缩小到超过一定的大小时,它就不好用了,一个纹理在渲染表面所占大小减少得越多,就会有越多的纹理元素拥挤到每一个片段上,因为OpenGL的双线性过滤只给每个片段使用四个纹理元素,我们将会失去很多细节,因为每一帧都要选择不同的纹理元素,这还会引起噪音以及移动中的物体闪烁.`  
`为了克服这些缺陷,可以使用MIP贴图(mipmapping)技术,它可以用来生成一组优化过的不同大小的纹理,当生成这组纹理的时候,OpenGL会使用所有的纹理元素生成每个级别的纹理,当过滤纹理时,还要确保所有的纹理元素都能被使用.在渲染时,OpenGL会根据每个片段的纹理元素数量为每个片段选择最适合的级别.`  
`使用MIP贴图,会占用更多的内存,但是渲染速度也会更快,这是因为较小级别的纹理在GPU的纹理缓存中占用较少的空间.`
* 三线性过滤器  
`如果OpenGL 在不同的MIP贴图级别之间来回切换,当我们用双线性过滤器来使用MIP贴图时,在其渲染的场景中,在不同级别的MIP贴图切换时,我们有时候能看到明显的跳跃或者线条.我们可以切换到三线性过滤(trilinear filtering),告诉OpenGL 在两个最邻近的MIP贴图级别之间也要插值,这样,每个片段总共要使用8个纹理元素插值.这有助于消除每个MIP贴图级别之间的过渡,并且得到一个更平滑的图像.`  
#### OpenGL纹理设置
```java
/**
* GL_TEXTURE_MIN_FILTER :是指缩小的情况
* - GL_LINEAR_MIPMAP_LINEAR: 告诉OpenGL 使用三线性过滤,
* 允许过滤的模式:
* GL_NEAREST
* GL_NEAREST_MIPMAP_LINEAR
* GL_NEAREST_MIPMAP_NEAREST
* GL_LINEAR
* GL_LINEAR_MIPMAP_LINEAR
*GL_LINEAR_MIPMAP_NEAREST
*
*
* GL_TEXTURE_MAG_FILTER : 是指放大的情况
* 我们设置放大过滤器为 GL_LINEAR, 是双线性过滤器
* 允许过滤的模式:
*GL_NEAREST
* GL_LINEAR
*
*
*
* GL_NEAREST : 最近邻过滤器
* GL_NEAREST_MIPMAP_LINEAR     使用MIP贴图的最近邻过滤器
* GL_NEAREST_MIPMAP_NEAREST    使用MIP贴图界别之间插值的最近邻过滤器
* GL_LINEAR    双线性过滤器
* GL_LINEAR_MIPMAP_LINEAR      使用MIP贴图的双线性过滤器
*GL_LINEAR_MIPMAP_NEAREST      三线性过滤器(使用MIP贴图级别之间插值的双线性过滤器)
*/
```
