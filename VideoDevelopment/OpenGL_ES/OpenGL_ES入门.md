[TOC]
# OpenGL ES 入门
* 什么是OpenGL,`OpenGL 开放图形库或者开放式图形库,是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口。`
* OpenGL ES ，在移动平台上使用的是一个特殊的嵌入式版本，叫做OpenGL ES
## 准备开始
`GLSurface View初始化OpenGL,GLSurfaceView会处理OpenGL初始化过程中比较基本的操作.`
* 字节序
```
字节序(Endianness) 是描述一个硬件架构是如何组织位(bit)和字节(byte) 的方式,他的
底层组成一个数字.现实中,最常见的就是多字节数,既可以吧他们按大头序(big endian order)排列,即吧最重要的自己放在前面;或者按小头序(little endian order)排列,即把最不重要的字节放前面.
	举个例子,有十进制数10000,如果把它转成二进制数,就是10011100010000.在大头架构上,这些位就会排列成:
	00100111 00010000
	在小头的架构上,他们就会排列成:
	00010000 00100111
	这次试用十六进制再来看一下,十进制10000就是十六进制系统中的2710;因为每两个字符对应一个8位自己,在看计算机代码时,十六进制用起来更好些;在大头的架构上,这个数字会另存为:
	27 10
	而在小头的架构上,同样的数字会另存为:
	10 27
	正常情况下,我们不需要担心字节序.当使用ByteBuffer时,只需要保证它和硬件使用了同样的字节序;否则结果就会莫名其妙的错误.
```
---
* 着色器(shader)
1. 顶点着色器(vertex shader)生成每个顶点的最终位置,针对每个顶点,它都会执行一次;一旦最终位置确定了,OpenGL就可以吧这些可见顶点的集合组装成点.直线.以及三角形.
2. 片段着色器(fragment shader) 为组成点. 直线和三角形的每个片段生成最终的颜色,针对每个片段,它都会执行一次,一个片段是一个小的,单一颜色的长方形区域,类似于计算机屏幕上的一个像素.  
`一旦最后的颜色生成了,OpenGL就会把它们写到一个称为帧缓冲区(frame buffer) 的内存块中,然后,Android会把这个帧缓冲区显示到屏幕上.`

```
res/raw/simple_fragment_shader.glsl

precision mediump float;
/*
OpenGL 设计者决定吧顶点着色器的精度默认设置为最高级--- highp
高精度数据类型更加精确,但是这是以降低性能为代价的;对于片段着色器,出于最大兼容性的考虑,选择了mediump,这也是基于速度和质量的权衡.
(精度分别有  highp, mediump, lowp)

Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。
全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。
第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。我们可以在一个着色器中添加uniform关键字至类型和变量名前来
声明一个GLSL的uniform。从此处开始我们就可以在着色器中使用新声明的uniform了。

我们在片段着色器中声明了一个uniform vec4的ourColor，并把片段着色器的输出颜色设置为uniform值的内容。
因为uniform是全局变量，我们可以在任何着色器中定义它们，而无需通过顶点着色器作为中介。顶点着色器中不需要这个uniform。

如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！

这个uniform现在还是空的，我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中uniform属性的索引/位置值。
当我们得到uniform的索引/位置值后，我们就可以更新它的值了。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色。

片段着色器剩余部分和早前定义的顶点着色器一样,这次要传递一个 unifrom ,它叫u_Color,它不像属性,每个顶点都要设置一个.一个uniform会让每个
顶点都使用同一个值,除非我们再次改变它,然后在mian(),把unifrom定义的颜色 复制给 gl_FragColor
*/

uniform vec4 u_Color;

void main()
{
    gl_FragColor = u_Color;
}






res/raw/simple_vertex_shader.glsl

attribute vec4 a_Position;

// 这些着色器 使用GLSL定义,GLSL是OpenGL 的着色语言;这个着色语言的语法结构与C 语言相似.
// 对于我们定义过的每个单一的顶点,顶点着色器都会被调用一次; 当它被调用的时候,它会在a_Position属性里面接手当前顶点的位置,这个属性被定义成vec4类型.
// 一个 vec4是包含4个分量的向量;在位置的上下文中,可以认为这4个分量是x,y,z,和w坐标,x,y,z对应一个三维位置,而w 是一个特殊的坐标.如果没有指定,默认情况下,OpenGL
//都是把向量的前三个坐标设为0,并把最后一个坐标w设为1.
/*
"attribute" 就是把这些属性放进着色器的手段,之后,可以定义main(),这是着色器的主要入口点,它所做的即使把前面定义过的位置复制到指定的输出变量gl_Position;
这个着色器一定要给gl_Position 赋值; OpenGL会把gl_Position中存储的值作为当前顶点的最终位置,并把这些顶点组装 成点,直线和三角形等.
*/
void main()
{
    gl_Position = a_Position;
    gl_PointSize = 10.0;
}
```
---
### matrix(矩阵) 和向量(vector)  

---

### 纹理 texture
`OpenGL中的纹理可以用来表示图像、照片、甚至由一个数学算法生成的分形数据。每个二维的纹理都由许多小的纹理元素(texel)组成,他们是小块的数据,类似于我们前面讨论过的片段和像素.要使用纹理,最常用的方式是直接从一个图像文件加载数据.`  
#### 纹理的坐标
- **常用说法**
* 二维纹理的左下角为(0,0), 水平方向的维度称为S,垂直方向的维度称为T. 当我们想把一个纹理应用于一个三角形或一组三角形的时候,我们要为每个顶点指定一组ST纹理坐标,以便OpenGl知道需要用那个纹理的哪个部分画到每个三角形上.
* S: {(0,0),(1,0)}
* T: {(0,0), (0,1)}

- **第二种说法**
* 对于三维模型,有两个最重要的坐标系统, 一个顶点的坐标(X,Y,Z).另外一个坐标,是UV坐标.完整的说应该是UVW(因为XYZ已经被定义,所以另选三个字母).  
* U:代表图片在显示器的水平方向的坐标, 0~1,
* V:代表图片在显示器的垂直方向作坐标,0~1
* W: 贴图时二维的,没有W坐标.
* 所以一般简称UV坐标。 坐标为（U {(0,0),(1,0)}, V{(0,0), (0,1)}）

`在OpenGl ES 2.0中,纹理不必是正方形,但是每个维度都应该是2个幂(POT 前面带个NPOT就是不是2的幂{non power of two}),每个维度都是这样的一个数字,如128,256,512等.这样的规定在与非POT纹理可以被使用的场景非常有限,而POT纹理适合各种场景.`
```
所以在 OpenGL中使用的纹理坐标应该是这样的,比如一张宽度512高度1024的图片,那么它的纹理坐标应该是0,0   1,0  1,1 0,1,
如果需要对纹理进行裁剪那么坐标可以是这样的, 
0.5,0.5(中心点)
0f,0.9f,
1f,0.9f,
1f,0.1f,
0f,0.1f,
0f,0.9f

```

#### 纹理过滤器
* 最近邻过滤器  
`这种方式为每个片段选择最近的纹理元素.当我们放大纹理时,它的锯齿效果看起来相当明显.每个纹理单元都清除的显示为一个小方块,当我们缩小纹理时,因为没有足够的片段用来绘制所有的纹理单元,许多细节将会丢失.`
* 双线性过滤器  
`双线性过滤使用双线性插值平滑像素之间的过渡,而不是为每个片段使用最近的纹理元素,OpenGL 会使用四个临近的纹理元素,并在他们之间用一个线性插值算法做插值,这个算法与我们4.3.2节中讨论过的算法一样.我们之所以叫它双线性,是因为它是沿着两个维度插值的.`  
* MIP贴图  
`尽管双线性过滤器很适合处理放大,但是对于缩小到超过一定的大小时,它就不好用了,一个纹理在渲染表面所占大小减少得越多,就会有越多的纹理元素拥挤到每一个片段上,因为OpenGL的双线性过滤只给每个片段使用四个纹理元素,我们将会失去很多细节,因为每一帧都要选择不同的纹理元素,这还会引起噪音以及移动中的物体闪烁.`  
`为了克服这些缺陷,可以使用MIP贴图(mipmapping)技术,它可以用来生成一组优化过的不同大小的纹理,当生成这组纹理的时候,OpenGL会使用所有的纹理元素生成每个级别的纹理,当过滤纹理时,还要确保所有的纹理元素都能被使用.在渲染时,OpenGL会根据每个片段的纹理元素数量为每个片段选择最适合的级别.`  
`使用MIP贴图,会占用更多的内存,但是渲染速度也会更快,这是因为较小级别的纹理在GPU的纹理缓存中占用较少的空间.`
* 三线性过滤器  
`如果OpenGL 在不同的MIP贴图级别之间来回切换,当我们用双线性过滤器来使用MIP贴图时,在其渲染的场景中,在不同级别的MIP贴图切换时,我们有时候能看到明显的跳跃或者线条.我们可以切换到三线性过滤(trilinear filtering),告诉OpenGL 在两个最邻近的MIP贴图级别之间也要插值,这样,每个片段总共要使用8个纹理元素插值.这有助于消除每个MIP贴图级别之间的过渡,并且得到一个更平滑的图像.`  
#### OpenGL纹理设置
```java
/**
* GL_TEXTURE_MIN_FILTER :是指缩小的情况
* - GL_LINEAR_MIPMAP_LINEAR: 告诉OpenGL 使用三线性过滤,
* 允许过滤的模式:
* GL_NEAREST
* GL_NEAREST_MIPMAP_LINEAR
* GL_NEAREST_MIPMAP_NEAREST
* GL_LINEAR
* GL_LINEAR_MIPMAP_LINEAR
*GL_LINEAR_MIPMAP_NEAREST
*
*
* GL_TEXTURE_MAG_FILTER : 是指放大的情况
* 我们设置放大过滤器为 GL_LINEAR, 是双线性过滤器
* 允许过滤的模式:
*GL_NEAREST
* GL_LINEAR
*
*
*
* GL_NEAREST : 最近邻过滤器
* GL_NEAREST_MIPMAP_LINEAR     使用MIP贴图的最近邻过滤器
* GL_NEAREST_MIPMAP_NEAREST    使用MIP贴图界别之间插值的最近邻过滤器
* GL_LINEAR    双线性过滤器
* GL_LINEAR_MIPMAP_LINEAR      使用MIP贴图的双线性过滤器
*GL_LINEAR_MIPMAP_NEAREST      三线性过滤器(使用MIP贴图级别之间插值的双线性过滤器)
*/
```
